## 编译过程
编译过程可以分为预处理(Prepressing)、编译(Compilation)、汇编(Assembly)和链接(Linking)

### 预编译
预编译过程主要处理源代码文件中的以"#"开始的预编译指令。比如"#include"、"#define"等，主要处理规则如下：
* 将所有的"#define"删除，并且展开所有的宏定义
* 处理所有条件预编译指令，比如"#if"、"#ifdef"、"#elif"、"#else"和"#endif"
* 处理"#include"预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的文件可能还包含其它文件
* 删除所有的注释
* 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号
* 保留所有的#pragma编译器指令，因为编译器要使用它们

```
gcc -E hello.c -o hello.i
```

### 编译
编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后产生相应的汇编代码文件

```
gcc -S hello.i -o hello.s
```

编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。
```
源代码 --scanner--> Tokens --Parser--> Syntax Tree --SemanticAnalyzer--> CommentedSyntaxTree --SourceCodeOptimizer--> IntermediateRepresentation --CodeGenerator--> Target Code --CodeOptimizer--> Final Target Code
```

中间代码使得编译器可以被分成前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

### 汇编
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。

```
as hello.s -o hello.o
```
or
```
gcc -c hello.s -o hello.o
```

### 链接
链接过程主要包括了地址和空间(Address and Storage Allocation)、符号决议(Symbol Resoulution)和重定位(Relocation)


## ELF
ELF中一些常见的段
| 常用的段名 | 说明 ｜
|:-----------|-------|
| .text | 代码 |
| .data | 初始化了的全局静态变量和局部变量 |
| .bss | 未初始化的全局变量和局部变量 |
| .rodata1 | Read only Data, 这种段里存放的是只读数据，比如字符串常量、全局const变量。跟".rodata"一样|
| .comment | 存放的是编译器版本信息，比如字符串: "GCC:(GNU) 4.2.0"|
| .debug | 调试信息 ｜
| .dynamic | 动态链接信息 |
| .hash | 符号哈希表 |
| .line | 调试时的行号表，即源代码行号与编译后指令的对应表 |
| .note | 额外的编译器信息。比如程序的公司名、发布版本号等 |
| .strtab | String Table，用于存储ELF文件中用到的各种字符串 |
| .symtab | Symbol Table 符号表 |
| .shstrtab | Section String Table 段名表 |
| .plt .got | 动态链接的跳转表和全局入口表 |
| .init .fini | 程序初始化与终结代码段 |

### 
ELF格式
```
|--------------------|
|     ELF Header     |
|--------------------|
|       .text        |
|--------------------|
|       .data        |
|--------------------|
|       .bss         |
|--------------------|
|        ...         |
|--------------------|
|   other sections   |
|--------------------|
|Section header table|
|--------------------|
|   String Tables    |
|--------------------|
|   Symbol Tables    |
|--------------------|

```
* ELF header，包含了描述整个文件的基本属性，比如ELF文件版本、目标机器型号、程序入口地址等。
* 段表(Section Header Table)，描述了ELF文件包含的所有段的信息，例如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。

.bss段在目标文件和可执行文件中并不占用文件的空间，但是它在装载时占用地址空间。

“链接器为目标文件分配地址和空间”这句话中的“地址和空间”其实有两个含义：
1. 在输出的可执行文件中的空间
2. 在装载后的虚拟地址中的虚拟地址空间

两步链接法：
1. 空间和地址分配。扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。
2. 符号解析与重定位。使用第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。
